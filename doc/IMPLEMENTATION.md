# Blink Message Playground - Phased Implementation Plan

**Project:** Blink Message Playground Web Application  
**Date:** 2026-01-21  
**Status:** Implementation Ready

---

## Technology Stack (Confirmed)

- **Frontend:** React 18+ with TypeScript
- **Backend:** FastAPI with uv package manager
- **Deployment:** Local development (localhost:3000 frontend, localhost:8000 backend)
- **Storage:** File-based JSON with 30-day retention
- **Styling:** Tailwind CSS for rapid development
- **Code Editor:** Monaco Editor (VS Code editor component)

---

## Project Structure

```
projects/pyblink/
├── backend/                    # FastAPI backend
│   ├── app/
│   │   ├── __init__.py
│   │   ├── main.py            # FastAPI app entry point
│   │   ├── api/
│   │   │   ├── __init__.py
│   │   │   ├── convert.py     # Conversion endpoints
│   │   │   ├── validate.py    # Validation endpoints
│   │   │   └── storage.py     # Save/load endpoints
│   │   ├── services/
│   │   │   ├── __init__.py
│   │   │   ├── converter.py   # Format conversion logic
│   │   │   ├── validator.py   # Schema validation
│   │   │   └── storage.py     # File storage management
│   │   └── models/
│   │       ├── __init__.py
│   │       └── schemas.py     # Pydantic models
│   ├── data/
│   │   └── playgrounds/       # Saved playground JSON files
│   ├── tests/
│   │   └── test_api.py
│   ├── pyproject.toml         # uv project config
│   └── README.md
│
├── frontend/                   # React frontend
│   ├── public/
│   │   └── index.html
│   ├── src/
│   │   ├── components/
│   │   │   ├── SchemaEditor.tsx
│   │   │   ├── InputPanel.tsx
│   │   │   ├── OutputPanel.tsx
│   │   │   ├── BinaryViewer.tsx
│   │   │   └── ShareLink.tsx
│   │   ├── services/
│   │   │   └── api.ts         # API client
│   │   ├── types/
│   │   │   └── index.ts       # TypeScript types
│   │   ├── App.tsx
│   │   └── index.tsx
│   ├── package.json
│   ├── tsconfig.json
│   └── tailwind.config.js
│
└── doc/
    ├── WEB_DESIGN.md          # Overall design document
    └── IMPLEMENTATION.md      # This file
```

---

## Phase 1: Backend Foundation (Week 1)

### Goals
- Set up FastAPI project with uv
- Implement core conversion API
- Integrate PyBlink codecs
- Basic error handling

### Tasks

#### 1.1 Project Setup
- [ ] Create `backend/` directory structure
- [ ] Initialize uv project: `uv init backend`
- [ ] Add dependencies to `pyproject.toml`:
  - `fastapi`
  - `uvicorn[standard]`
  - `pydantic`
  - `python-multipart`
- [ ] Add PyBlink as local dependency
- [ ] Create `.gitignore` for backend

#### 1.2 FastAPI Application
- [ ] Create `app/main.py` with FastAPI app
- [ ] Add CORS middleware for local development
- [ ] Set up logging configuration
- [ ] Add health check endpoint: `GET /health`

#### 1.3 Conversion Service
- [ ] Create `services/converter.py`
- [ ] Implement schema compilation
- [ ] Implement format detection
- [ ] Implement conversion logic:
  - Tag → Message
  - JSON → Message
  - XML → Message
  - Compact Binary (hex) → Message
  - Native Binary (hex) → Message
  - Message → all formats
- [ ] Add hex encoding/decoding utilities
- [ ] Add binary decoded view generation

#### 1.4 API Endpoints
- [ ] Create `api/convert.py`
- [ ] Implement `POST /api/convert`:
  - Request: schema, input_format, input_data
  - Response: all output formats + binary views
- [ ] Add request validation (Pydantic models)
- [ ] Add error handling and formatting
- [ ] Add response models

#### 1.5 Testing
- [ ] Write unit tests for converter service
- [ ] Write API endpoint tests
- [ ] Test all format conversions
- [ ] Test error scenarios

### Deliverables
- ✅ Working FastAPI backend
- ✅ `/api/convert` endpoint functional
- ✅ All format conversions working
- ✅ Test suite passing
- ✅ API documentation (auto-generated by FastAPI)

### Success Criteria
- Can convert a simple message between all 5 formats
- API returns proper error messages for invalid input
- Response time < 500ms for simple messages

---

## Phase 2: Frontend Foundation (Week 2)

### Goals
- Set up React project with TypeScript
- Create basic UI layout
- Implement schema and input editors
- Connect to backend API

### Tasks

#### 2.1 Project Setup
- [ ] Create React app: `npx create-react-app frontend --template typescript`
- [ ] Install dependencies:
  - `@monaco-editor/react` (code editor)
  - `tailwindcss`
  - `axios` (HTTP client)
  - `lucide-react` (icons)
- [ ] Configure Tailwind CSS
- [ ] Set up TypeScript types
- [ ] Create `.env` for API URL

#### 2.2 Layout & Styling
- [ ] Create main app layout (header, content, footer)
- [ ] Implement responsive grid system
- [ ] Create color scheme and CSS variables
- [ ] Add dark mode support (optional)
- [ ] Create reusable UI components (Button, Card, etc.)

#### 2.3 Schema Editor Component
- [ ] Create `SchemaEditor.tsx`
- [ ] Integrate Monaco Editor
- [ ] Add Blink syntax highlighting (basic)
- [ ] Add validation button
- [ ] Display validation errors
- [ ] Add line numbers and error markers

#### 2.4 Input Panel Component
- [ ] Create `InputPanel.tsx`
- [ ] Add format selector dropdown
- [ ] Integrate Monaco Editor for text formats
- [ ] Create hex input mode for binary formats
- [ ] Add "Convert" button
- [ ] Add loading state

#### 2.5 API Integration
- [ ] Create `services/api.ts`
- [ ] Implement `convertMessage()` function
- [ ] Add error handling
- [ ] Add loading states
- [ ] Type API responses

#### 2.6 Basic Output Display
- [ ] Create `OutputPanel.tsx`
- [ ] Display converted formats (text only for now)
- [ ] Add copy-to-clipboard buttons
- [ ] Add collapsible sections

### Deliverables
- ✅ React app running on localhost:3000
- ✅ Schema editor with Monaco
- ✅ Input panel with format selection
- ✅ Basic output display
- ✅ API integration working

### Success Criteria
- User can input schema and message
- User can select input format
- User can click "Convert" and see outputs
- UI is responsive and looks clean

---

## Phase 3: Binary Viewers (Week 3)

### Goals
- Implement hex viewer for binary formats
- Implement decoded view with annotations
- Add interactive features

### Tasks

#### 3.1 Hex Viewer Component
- [ ] Create `BinaryViewer.tsx`
- [ ] Implement hex dump display:
  - Offset column (0000, 0010, etc.)
  - Hex bytes (16 per row)
  - ASCII preview column
  - Byte grouping (4 or 8 bytes)
- [ ] Add syntax highlighting for hex
- [ ] Add hover tooltips (show decimal value)
- [ ] Add copy hex button

#### 3.2 Decoded View Component
- [ ] Create `DecodedView.tsx`
- [ ] Display message structure:
  - Size, Type ID, Extension Offset
  - Field-by-field breakdown
  - Offset annotations
  - Value interpretations
- [ ] Add collapsible sections for nested data
- [ ] Add color coding for field types
- [ ] Link hex view to decoded view (highlight on hover)

#### 3.3 Backend Enhancements
- [ ] Update `/api/convert` to return detailed binary info:
  - Byte-by-byte breakdown
  - Field offsets
  - Type information
- [ ] Add hex formatting utilities
- [ ] Add offset calculation helpers

#### 3.4 Interactive Features
- [ ] Implement hover highlighting:
  - Hover over decoded field → highlight hex bytes
  - Hover over hex bytes → highlight decoded field
- [ ] Add byte selection (click to select range)
- [ ] Add field expansion/collapse
- [ ] Add download as .bin file

### Deliverables
- ✅ Complete hex viewer
- ✅ Detailed decoded view
- ✅ Interactive highlighting
- ✅ Download functionality

### Success Criteria
- Binary formats display clearly
- User can understand message structure
- Hex and decoded views are linked
- Performance is good for large messages (up to 10KB)

---

## Phase 4: Save/Load System (Week 4)

### Goals
- Implement file-based storage
- Create save/load API endpoints
- Add URL parameter handling
- Implement 30-day cleanup

### Tasks

#### 4.1 Storage Service
- [ ] Create `services/storage.py`
- [ ] Implement ID generation (8-char alphanumeric)
- [ ] Implement file save/load:
  - Save to `data/playgrounds/{id}.json`
  - Load from file by ID
  - Handle file not found errors
- [ ] Add metadata (created timestamp, title, description)
- [ ] Implement cleanup on startup:
  - Scan `data/playgrounds/`
  - Delete files older than 30 days
  - Log cleanup results

#### 4.2 API Endpoints
- [ ] Create `api/storage.py`
- [ ] Implement `POST /api/save`:
  - Validate input
  - Generate unique ID
  - Save to file
  - Return ID and URL
- [ ] Implement `GET /api/load/{id}`:
  - Load file by ID
  - Return playground data
  - Handle not found (404)
- [ ] Add request/response models

#### 4.3 Frontend Integration
- [ ] Create `ShareLink.tsx` component
- [ ] Add "Save" button to header
- [ ] Implement save modal:
  - Optional title/description
  - Show generated link
  - Copy link button
- [ ] Add URL parameter parsing:
  - Check for `?p={id}` parameter
  - Auto-load playground on mount
  - Display loading state
- [ ] Add "Load" indicator when loading from URL

#### 4.4 Testing
- [ ] Test save/load workflow
- [ ] Test ID uniqueness
- [ ] Test 30-day cleanup logic
- [ ] Test error handling (file not found, etc.)
- [ ] Test URL parameter handling

### Deliverables
- ✅ Working save/load system
- ✅ Shareable URLs
- ✅ 30-day auto-cleanup
- ✅ Error handling

### Success Criteria
- User can save playground and get link
- User can load playground from link
- Old playgrounds are auto-deleted
- System handles errors gracefully

---

## Phase 5: Polish & Enhancement (Week 5)

### Goals
- Add syntax highlighting for all formats
- Implement example library
- Add keyboard shortcuts
- Improve error handling
- Performance optimization

### Tasks

#### 5.1 Syntax Highlighting
- [ ] Add Blink schema syntax highlighting (Monaco custom language)
- [ ] Add JSON syntax highlighting (built-in)
- [ ] Add XML syntax highlighting (built-in)
- [ ] Add Tag format highlighting (custom)
- [ ] Test all highlighting modes

#### 5.2 Example Library
- [ ] Create example schemas:
  - Simple Person
  - Trading Order
  - Nested Groups
  - Dynamic Groups
  - Sequences
- [ ] Add "Examples" dropdown
- [ ] Implement example loading
- [ ] Add example descriptions

#### 5.3 User Experience
- [ ] Add keyboard shortcuts:
  - `Ctrl+Enter` to convert
  - `Ctrl+S` to save
  - `Ctrl+/` to toggle comments
- [ ] Add loading spinners
- [ ] Add success/error toasts
- [ ] Add auto-save to localStorage (draft)
- [ ] Add "Clear All" button

#### 5.4 Error Handling
- [ ] Improve error messages:
  - Schema errors with line numbers
  - Input parsing errors
  - Conversion errors
- [ ] Add error recovery suggestions
- [ ] Add validation warnings (non-blocking)
- [ ] Add error boundary component

#### 5.5 Performance
- [ ] Optimize Monaco Editor loading
- [ ] Add debouncing for validation (500ms)
- [ ] Lazy load output panels
- [ ] Optimize hex viewer for large messages
- [ ] Add virtual scrolling if needed

#### 5.6 Documentation
- [ ] Write user guide (in-app help)
- [ ] Add tooltips for UI elements
- [ ] Create README for backend
- [ ] Create README for frontend
- [ ] Add API documentation examples

### Deliverables
- ✅ Polished UI with syntax highlighting
- ✅ Example library
- ✅ Keyboard shortcuts
- ✅ Improved error handling
- ✅ Performance optimizations
- ✅ User documentation

### Success Criteria
- App feels responsive and polished
- Users can easily learn the interface
- Errors are clear and helpful
- Performance is smooth for typical use cases

---

## Phase 6: Testing & Deployment (Week 6)

### Goals
- Comprehensive testing
- Production-ready configuration
- Deployment documentation
- User acceptance testing

### Tasks

#### 6.1 Backend Testing
- [ ] Achieve 80%+ test coverage
- [ ] Add integration tests
- [ ] Test all error scenarios
- [ ] Performance testing (load test)
- [ ] Security review (input validation)

#### 6.2 Frontend Testing
- [ ] Manual testing all features
- [ ] Cross-browser testing:
  - Chrome
  - Firefox
  - Safari
  - Edge
- [ ] Mobile responsiveness testing
- [ ] Accessibility testing (keyboard navigation)

#### 6.3 Production Configuration
- [ ] Create production build scripts
- [ ] Configure environment variables
- [ ] Set up logging
- [ ] Add rate limiting (optional)
- [ ] Add request size limits

#### 6.4 Deployment Documentation
- [ ] Write deployment guide:
  - Backend setup (uv install)
  - Frontend build (npm run build)
  - Running locally
  - Environment variables
- [ ] Create startup scripts
- [ ] Document troubleshooting

#### 6.5 User Acceptance Testing
- [ ] Test with real users
- [ ] Gather feedback
- [ ] Fix critical issues
- [ ] Prioritize enhancements

### Deliverables
- ✅ Comprehensive test suite
- ✅ Production-ready application
- ✅ Deployment documentation
- ✅ User feedback incorporated

### Success Criteria
- All tests passing
- No critical bugs
- App runs smoothly locally
- Documentation is clear

---

## Development Workflow

### Daily Workflow
1. **Morning:** Review tasks for the day
2. **Development:** Implement features, write tests
3. **Testing:** Run tests, manual testing
4. **Commit:** Commit working code with clear messages
5. **Evening:** Update progress, plan next day

### Git Workflow
```bash
# Feature branch workflow
git checkout -b phase-1-backend-foundation
# ... make changes ...
git add .
git commit -m "feat: implement conversion API endpoint"
git push origin phase-1-backend-foundation
# Merge to main when phase complete
```

### Testing Workflow
```bash
# Backend tests
cd backend
uv run pytest tests/ -v

# Frontend tests (manual for now)
cd frontend
npm start
# Manual testing in browser
```

### Running the Application
```bash
# Terminal 1: Backend
cd backend
uv run uvicorn app.main:app --reload --port 8000

# Terminal 2: Frontend
cd frontend
npm start
# Opens http://localhost:3000
```

---

## Phase Completion Checklist

### Phase 1: Backend Foundation
- [ ] All tasks completed
- [ ] Tests passing (80%+ coverage)
- [ ] API documented
- [ ] Code reviewed
- [ ] Merged to main

### Phase 2: Frontend Foundation
- [ ] All tasks completed
- [ ] UI looks clean and responsive
- [ ] API integration working
- [ ] Code reviewed
- [ ] Merged to main

### Phase 3: Binary Viewers
- [ ] All tasks completed
- [ ] Hex viewer working
- [ ] Decoded view working
- [ ] Interactive features working
- [ ] Code reviewed
- [ ] Merged to main

### Phase 4: Save/Load System
- [ ] All tasks completed
- [ ] Save/load working
- [ ] URL parameters working
- [ ] Cleanup tested
- [ ] Code reviewed
- [ ] Merged to main

### Phase 5: Polish & Enhancement
- [ ] All tasks completed
- [ ] Syntax highlighting working
- [ ] Examples library working
- [ ] Performance optimized
- [ ] Code reviewed
- [ ] Merged to main

### Phase 6: Testing & Deployment
- [ ] All tasks completed
- [ ] Tests passing
- [ ] Documentation complete
- [ ] User acceptance done
- [ ] Ready for production

---

## Risk Management

### Technical Risks

| Risk | Impact | Mitigation |
|------|--------|------------|
| Monaco Editor too heavy | High | Use CodeMirror as fallback |
| Binary viewer performance | Medium | Implement virtual scrolling |
| CORS issues | Low | Configure properly in FastAPI |
| File storage limits | Low | Add disk space monitoring |

### Schedule Risks

| Risk | Impact | Mitigation |
|------|--------|------------|
| Scope creep | High | Stick to phased plan, defer enhancements |
| Underestimated complexity | Medium | Buffer time in each phase |
| Dependency issues | Low | Use stable versions, lock dependencies |

---

## Success Metrics

### Phase Completion Metrics
- **Phase 1:** API converts messages successfully
- **Phase 2:** UI displays all formats
- **Phase 3:** Binary views are clear and interactive
- **Phase 4:** Save/load works end-to-end
- **Phase 5:** App feels polished and fast
- **Phase 6:** No critical bugs, ready for use

### Overall Success Metrics
- **Functionality:** All core features working
- **Performance:** Conversion < 500ms, page load < 2s
- **Usability:** Users can complete tasks without help
- **Reliability:** No crashes, graceful error handling

---

## Next Steps

1. **Review this plan** - Confirm approach and timeline
2. **Set up development environment** - Install tools
3. **Start Phase 1** - Begin backend implementation
4. **Iterate** - Complete phases sequentially
5. **Deploy** - Launch locally for testing

---

## Appendix: Technology Setup

### Backend Setup (uv + FastAPI)
```bash
# Install uv (if not already installed)
curl -LsSf https://astral.sh/uv/install.sh | sh

# Create backend project
cd projects/pyblink
mkdir backend
cd backend
uv init

# Add dependencies
uv add fastapi uvicorn[standard] pydantic python-multipart

# Run development server
uv run uvicorn app.main:app --reload --port 8000
```

### Frontend Setup (React + TypeScript)
```bash
# Create React app
cd projects/pyblink
npx create-react-app frontend --template typescript

# Install dependencies
cd frontend
npm install @monaco-editor/react axios lucide-react
npm install -D tailwindcss postcss autoprefixer
npx tailwindcss init -p

# Start development server
npm start
```

### VS Code Extensions (Recommended)
- Python (Microsoft)
- Pylance
- ESLint
- Prettier
- Tailwind CSS IntelliSense
- TypeScript and JavaScript Language Features

---

**End of Implementation Plan**
